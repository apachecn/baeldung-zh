# 一个简单的带有弹性搜索的标签实现

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/elasticsearch-tagging>

[This article is part of a series:](javascript:void(0);)• A Simple Tagging Implementation with Elasticsearch (current article)[• A Simple Tagging Implementation with JPA](/web/20220630140827/https://www.baeldung.com/jpa-tagging)
[• An Advanced Tagging Implementation with JPA](/web/20220630140827/https://www.baeldung.com/jpa-tagging-advanced)
[• A Simple Tagging Implementation with MongoDB](/web/20220630140827/https://www.baeldung.com/mongodb-tagging)

## **1。概述**

标记是一种常见的设计模式，它允许我们对数据模型中的项目进行分类和过滤。

在本文中，我们将使用 Spring 和 Elasticsearch 实现标记。我们将同时使用 Spring 数据和 Elasticsearch API。

首先，我们不打算涵盖获取 Elasticsearch 和 Spring 数据的基础知识——您可以在这里探索这些内容。

## **2。添加标签**

最简单的标记实现是一个字符串数组。我们可以通过向我们的数据模型添加一个新字段来实现这一点，如下所示:

```
@Document(indexName = "blog", type = "article")
public class Article {

    // ...

    @Field(type = Keyword)
    private String[] tags;

    // ...
}
```

注意`Keyword `字段类型的使用。我们只想精确匹配我们的标签来过滤结果。这允许我们使用类似但独立的标签，如`elasticsearchIsAwesome`和`elasticsearchIsTerrible`。

在这种情况下，分析的字段将返回部分命中，这是错误的行为。

## **3。建筑查询**

标签允许我们以有趣的方式操作我们的查询。我们可以像搜索任何其他字段一样搜索它们，或者我们可以使用它们来过滤我们对`match_all`查询的结果。我们还可以将它们与其他查询一起使用，以强化我们的结果。

### **3.1。搜索标签**

我们在模型上创建的新的`tag`字段就像我们索引中的其他字段一样。我们可以搜索具有如下特定标签的任何实体:

```
@Query("{\"bool\": {\"must\": [{\"match\": {\"tags\": \"?0\"}}]}}")
Page<Article> findByTagUsingDeclaredQuery(String tag, Pageable pageable);
```

这个例子使用 Spring 数据存储库来构建我们的查询，但是我们可以同样快速地使用一个 [Rest 模板](https://web.archive.org/web/20220630140827/https://docs.spring.io/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html)来手动查询 Elasticsearch 集群。

同样，我们可以使用 Elasticsearch API:

```
boolQuery().must(termQuery("tags", "elasticsearch"));
```

假设我们在索引中使用了以下文档:

```
[
    {
        "id": 1,
        "title": "Spring Data Elasticsearch",
        "authors": [ { "name": "John Doe" }, { "name": "John Smith" } ],
        "tags": [ "elasticsearch", "spring data" ]
    },
    {
        "id": 2,
        "title": "Search engines",
        "authors": [ { "name": "John Doe" } ],
        "tags": [ "search engines", "tutorial" ]
    },
    {
        "id": 3,
        "title": "Second Article About Elasticsearch",
        "authors": [ { "name": "John Smith" } ],
        "tags": [ "elasticsearch", "spring data" ]
    },
    {
        "id": 4,
        "title": "Elasticsearch Tutorial",
        "authors": [ { "name": "John Doe" } ],
        "tags": [ "elasticsearch" ]
    },
]
```

现在我们可以使用这个查询:

```
Page<Article> articleByTags 
  = articleService.findByTagUsingDeclaredQuery("elasticsearch", PageRequest.of(0, 10));

// articleByTags will contain 3 articles [ 1, 3, 4]
assertThat(articleByTags, containsInAnyOrder(
 hasProperty("id", is(1)),
 hasProperty("id", is(3)),
 hasProperty("id", is(4)))
);
```

### **3.2。过滤所有文件**

一个常见的设计模式是在 UI 中创建一个`Filtered List View`来显示所有的实体，但也允许用户根据不同的标准进行过滤。

假设我们想返回所有根据用户选择的标签过滤的文章:

```
@Query("{\"bool\": {\"must\": " +
  "{\"match_all\": {}}, \"filter\": {\"term\": {\"tags\": \"?0\" }}}}")
Page<Article> findByFilteredTagQuery(String tag, Pageable pageable);
```

我们再次使用 Spring 数据来构造我们声明的查询。

因此，我们使用的查询被分成两部分。评分查询是第一个术语，在本例中是`match_all`。接下来是过滤器查询，它告诉 Elasticsearch 要丢弃哪些结果。

下面是我们如何使用这个查询:

```
Page<Article> articleByTags =
  articleService.findByFilteredTagQuery("elasticsearch", PageRequest.of(0, 10));

// articleByTags will contain 3 articles [ 1, 3, 4]
assertThat(articleByTags, containsInAnyOrder(
  hasProperty("id", is(1)),
  hasProperty("id", is(3)),
  hasProperty("id", is(4)))
);
```

重要的是要认识到，虽然这与我们上面的例子返回相同的结果，但是这个查询会执行得更好。

### **3.3。过滤查询**

有时搜索会返回太多不可用的结果。在这种情况下，最好公开一种过滤机制，可以重新运行相同的搜索，只是结果范围缩小了。

这里有一个例子，我们将作者写的文章缩小到只有带有特定标签的文章:

```
@Query("{\"bool\": {\"must\": " + 
  "{\"match\": {\"authors.name\": \"?0\"}}, " +
  "\"filter\": {\"term\": {\"tags\": \"?1\" }}}}")
Page<Article> findByAuthorsNameAndFilteredTagQuery(
  String name, String tag, Pageable pageable);
```

同样，Spring Data 为我们做了所有的工作。

让我们看看如何自己构造这个查询:

```
QueryBuilder builder = boolQuery().must(
  nestedQuery("authors", boolQuery().must(termQuery("authors.name", "doe")), ScoreMode.None))
  .filter(termQuery("tags", "elasticsearch"));
```

当然，我们可以使用同样的技术来过滤文档中的任何其他字段。但是标签特别适合这个用例。

下面是如何使用上面的查询:

```
SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(builder)
  .build();
List<Article> articles = 
  elasticsearchTemplate.queryForList(searchQuery, Article.class);

// articles contains [ 1, 4 ]
assertThat(articleByTags, containsInAnyOrder(
 hasProperty("id", is(1)),
 hasProperty("id", is(4)))
);
```

## **4。过滤上下文**

当我们构建查询时，我们需要区分查询上下文和过滤器上下文。Elasticsearch 中的每个查询都有一个查询上下文，所以我们应该习惯于看到它们。

并非每种查询类型都支持过滤器上下文。因此，如果我们想过滤标签，我们需要知道我们可以使用哪些查询类型。

**`bool`查询有两种方式访问过滤上下文**。第一个参数， **`filter`** ，就是我们上面用的那个。我们也可以使用一个 **`must_not`** 参数来激活上下文。

**我们可以过滤的下一个查询类型是`constant_score`** 。当 uu 想要用过滤器的结果替换查询上下文并给每个结果分配相同的分数时，这很有用。

**我们可以根据标签过滤的最终查询类型是`filter aggregation`** 。这允许我们基于我们的过滤器的结果创建聚合组。换句话说，我们可以在聚合结果中按标签对所有文章进行分组。

## **5。高级标记**

到目前为止，我们只讨论了使用最基本的实现进行标记。下一个逻辑步骤是创建本身是`key-value pairs`的标签。这将允许我们用我们的查询和过滤器变得更好。

例如，我们可以将标记字段更改为:

```
@Field(type = Nested)
private List<Tag> tags;
```

然后我们只需改变我们的过滤器来使用`nestedQuery`类型。

一旦我们理解了如何使用`key-value pairs`,就向使用复杂的对象作为我们的标签迈出了一小步。没有多少实现需要一个完整的对象作为标签，但是如果需要的话，知道我们有这个选项是很好的。

## **6。结论**

在本文中，我们已经介绍了使用 Elasticsearch 实现标记的基础知识。

像往常一样，可以在 GitHub 上找到例子[。](https://web.archive.org/web/20220630140827/https://github.com/eugenp/tutorials/tree/master/persistence-modules/spring-data-elasticsearch)

Next **»**[A Simple Tagging Implementation with JPA](/web/20220630140827/https://www.baeldung.com/jpa-tagging)